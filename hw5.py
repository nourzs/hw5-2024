import pathlib
from typing import Tuple, Union

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

class QuestionnaireAnalysis:
    """Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    Usage: 'read_data' loads the data into memory, and the rest of the methods
    can be called out of order as they assume that the data is already in self.data.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        try:
            self.data_fname = pathlib.Path(data_fname).resolve()
        except TypeError:
            print("ERROR: Please supply a string or a pathlib.Path instance to the class.")
            raise
        if not self.data_fname.exists():
            raise ValueError(f"File {str(self.data_fname)} doesn't exist.")

    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to the attribute self.data."""
        self.data = pd.read_json(self.data_fname)

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants."""
        bins = np.linspace(0, 100, 11)
        _, ax = plt.subplots()
        hist, edges, _ = ax.hist(self.data["age"], bins=bins)
        ax.set_xlabel("Age")
        ax.set_ylabel("Counts")
        ax.set_title("Age distribution across all subjects")
        return hist, edges

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them."""
        valid_email = self.data["email"].apply(lambda x: self._validate_email(x))
        return self.data.loc[valid_email].reset_index(drop=True)

    def _validate_email(self, email: str) -> bool:
        """Checks if an email is valid."""
        return (
            "@" in email and "." in email and not email.endswith(".") and not email.endswith("@")
            and not email.startswith(".") and not email.startswith("@") and email.isascii()
            and email.count("@") == 1 and email[email.find("@") + 1] != "."
        )

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds rows with nulls and fills them with the mean of the respective student's scores."""
        rows_with_nulls = self._find_rows_with_nulls()  # Find indices before any changes
        only_grades = self._fill_na_with_mean()  # Get the modified grades
        self.data.loc[:, "q1":"q5"] = only_grades  # Update the main DataFrame
        return self.data, rows_with_nulls

    def _find_rows_with_nulls(self) -> np.ndarray:
        """Finds rows which contain at least one NA and returns their index as an array."""
        only_grades = self.data.loc[:, "q1":"q5"]
        rows_with_nulls = only_grades.loc[only_grades.isna().any(axis=1)].index.to_numpy()
        return rows_with_nulls

    def _fill_na_with_mean(self) -> pd.DataFrame:
        """Fills the dataframe with means instead of NAs."""
        only_grades = self.data.loc[:, "q1":"q5"]
        only_means = only_grades.mean(axis=1)
        only_means = pd.DataFrame({key: only_means for key in only_grades.columns})
        only_grades = only_grades.where(only_grades.notnull(), only_means)
        return only_grades

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates scores, handles NaNs appropriately, and ensures proper type conversions."""
        question_columns = self.data.loc[:, "q1":"q5"]
        more_than_maximal_nans_row_indices = question_columns.isna().sum(axis=1) > maximal_nans_per_sub
        self.data['score'] = question_columns.mean(axis=1, skipna=True).apply(np.floor).astype('UInt8')
        self.data.loc[more_than_maximal_nans_row_indices, 'score'] = pd.NA  # Apply NA after converting to UInt8
        return self.data

    def correlate_gender_age(self) -> pd.DataFrame:
        """Calculates correlation between gender, age, and scores."""
        self.data.dropna(subset=['age'], inplace=True)
        self.data['temp_age_group'] = self.data['age'] > 40
        self.data['age'] = self.data['temp_age_group']
        self.data.drop(columns=['temp_age_group'], inplace=True)
        self.data.set_index(['gender', 'age'], inplace=True)
        results = self.data[['q1', 'q2', 'q3', 'q4', 'q5']].groupby(level=['gender', 'age']).mean()
        return results
    


    


       
